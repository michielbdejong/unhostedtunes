/*
 * TransSession.h
 *
 *  Created on: Jan 17, 2013
 *      Author: fernando
 */

#ifndef TRANSSESSION_H_
#define TRANSSESSION_H_

#include "include.h"

#include <v8.h>
#include <node.h>

using namespace node;
using namespace v8;

#include <event2/buffer.h>

#include "Utils.h"

#include "libtransmission/transmission.h"
#include "libtransmission/bencode.h"
#include "libtransmission/tr-getopt.h"
#include "libtransmission/utils.h"
#include "libtransmission/version.h"
#include "libtransmission/torrent.h"
#include "libtransmission/session.h"
#include "libtransmission/web.h"
#include "transmissionDaemon/watch.h"


#define TRANSNODE_ERROR_THROWER(IDENTIFIER, ERR)                                  \
  V8_SCB(IDENTIFIER) {                                                         \
    v8::HandleScope handle;                                                    \
    return v8::ThrowException(ERR);                                            \
  }

// Use on abstract callbacks
//V8_SCB(_isAbstract);


// Conversion and escaping goodies
//buildPathList


// Macros for asynchronous work
// --based on node-lame's code

//Unwrapping and starting work statement-macros
//TODO: DO SOMETHING WITH STRINGS THAT CONTAIN '\0'
#define TRANSNODE_ASYNC_CSTR(OBJ, VAR)                                            \
  int VAR##_len = OBJ->length();                                               \
  char* VAR = new char[VAR##_len+1];                                           \
  memcpy(VAR, **OBJ, VAR##_len);                                               \
  delete OBJ;                                                                  \
  VAR[VAR##_len] = 0
#define TRANSNODE_SYNC_CSTR(OBJ, VAR)                                             \
  int VAR##_len = OBJ.length();                                                \
  char* VAR = new char[VAR##_len+1];                                           \
  memcpy(VAR, *OBJ, VAR##_len);                                                \
  VAR[VAR##_len] = 0

#define TRANSNODE_WORK_UNWRAP(IDENTIFIER)                                         \
  IDENTIFIER##_req* r = (IDENTIFIER##_req*)req->data
#define TRANSNODE_WORK_QUEUE(IDENTIFIER)                                          \
  r->req.data = r;                                                             \
  return v8::Integer::New(uv_queue_work(uv_default_loop(), &r->req,            \
                                        IDENTIFIER##_work, (uv_after_work_cb)IDENTIFIER##_after))
#define TRANSNODE_WORK_CALL(ARGC)                                                 \
  v8::TryCatch try_catch;                                                      \
  r->cb->Call(v8::Context::GetCurrent()->Global(), ARGC, argv);                \
  r->cb.Dispose();                                                             \
  delete r;                                                                    \
  if (try_catch.HasCaught()) node::FatalException(try_catch)

#define TRANSNODE_CB_CALL(ARGC)                                             \
  v8::TryCatch try_catch;                                                      \
  r->cb->Call(v8::Context::GetCurrent()->Global(), ARGC, argv);                \
  r->cb.Dispose();                                                             \
  if (try_catch.HasCaught()) node::FatalException(try_catch)

//Work callbacks block-macros
#define TRANSNODE_WORK_PRE(IDENTIFIER)                                            \
  void IDENTIFIER##_work(uv_work_t *req);                                      \
  void IDENTIFIER##_after(uv_work_t *req);                                     \
  struct IDENTIFIER##_req

#define TRANSNODE_WORK(IDENTIFIER)                                                \
  void IDENTIFIER##_work(uv_work_t *req) {                                     \
    TRANSNODE_WORK_UNWRAP(IDENTIFIER);

#define TRANSNODE_WORK_AFTER(IDENTIFIER) }                                        \
  void IDENTIFIER##_after(uv_work_t *req) {                                    \
    v8::HandleScope scope;                                                     \
    TRANSNODE_WORK_UNWRAP(IDENTIFIER);

#define TRANSNODE_END }

#define TRANSNODE_CHECK_CB_ARGS(MIN)                                              \
  if (len < 1) V8_STHROW(v8u::RangeErr("Not enough arguments!"));


#define PREF_KEY_DIR_WATCH          "watch-dir"
#define PREF_KEY_DIR_WATCH_ENABLED  "watch-dir-enabled"

#define MEM_K 1024
#define MEM_K_STR "KiB"
#define MEM_M_STR "MiB"
#define MEM_G_STR "GiB"
#define MEM_T_STR "TiB"

#define DISK_K 1000
#define DISK_B_STR  "B"
#define DISK_K_STR "kB"
#define DISK_M_STR "MB"
#define DISK_G_STR "GB"
#define DISK_T_STR "TB"

#define SPEED_K 1000
#define SPEED_B_STR  "B/s"
#define SPEED_K_STR "kB/s"
#define SPEED_M_STR "MB/s"
#define SPEED_G_STR "GB/s"
#define SPEED_T_STR "TB/s"

struct TorrentStat
{
	int error;
	char errorString[512];
	int eta;
	int id;
	bool isFinished;
	uint64_t leftUntilDone;
	char name[512];
	int peersGettingFromUs;
	int peersSendingToUs;
	float rateDownload;
	float rateUpload;
	uint64_t sizeWhenDone;
	tr_torrent_activity status;
	float uploadRatio;
	tr_file_index_t numFiles;
	tr_file_stat * fileStats;
};

struct TorrentsStat
{
	int totalTorrents;
	TorrentStat* torrentStatList;
};

void idle_tn(uv_idle_t* handle, int status);

struct session_events_req {
	Persistent<Function> cb;
	tr_evt_list * list;
	uv_work_t req;
};

struct idle_events_req;


class TransSession {

	private:
		dtr_watchdir * watchdir;
		tr_session * session;
		//session_events_req * events;
		idle_events_req * idle_req;
		//Persistent<Function> event_cb;
		string sessionConfigDir;

	public:
		TransSession(string sessionConfigDir, Persistent<Function> event_cb);
		virtual ~TransSession();
		string getTorrentStatusString (TorrentStat torrentStat);
		string start();
		void idle();
		//void idle(uv_idle_t* handle, int status);
		void stop();

		int addTorrent(string filePath);
		int addMagnet(string filePath, int offset);
		int addURL(string filePath);
		struct TorrentsStat *listTorrents();
		int stopTorrent(int torrentId);
		int startTorrent(int torrentId, bool bypass_queue);
		int removeTorrent(int torrentId, bool deleteLocalData);
		void pumpLogMessages();
		void pumpEvents();
		void emit(const char * evt, Handle<Object> data);
};

struct idle_events_req {
	TransSession* session;
	Persistent<Function> cb;
	uv_timer_t req;
};

#endif /* TRANSSESSION_H_ */
