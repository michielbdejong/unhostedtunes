/*
 * transNode.cpp
 *
 *  Created on: Dec 20, 2012
 *      Author: fernando
 */

#include <v8.h>
#include <node.h>

using namespace node;
using namespace v8;

#include "transNode.h"
#include "PathsManager.h"
#include "FrameExtractor.h"
#include "TorrentCreator.h"
#include "TransSession.h"

#include "v8u.hpp"

//static bool isSuscribed = false;
//static pthread_t status_change_thread;
static uv_async_t status_change_notifier;
//static uv_loop_t *loop;
//queue<Baton_req *> queue_msg = std::queue<Baton_req *>();
//pthread_mutex_t queue_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t suscribe_mutex = PTHREAD_MUTEX_INITIALIZER;

static TransSession *transSession = NULL;


TRANSNODE_WORK_PRE(mp3ToTorrent) {
	int errorStatus;
	string orgFilePath;
	string torrentFilePath;
	string uframeDirectory;
	string torrentDirectory;
	string uframeFilePath;
	string uframeHash;
	int pieceSize;

	Persistent<Function> cb;
	uv_work_t req;
};

V8_SCB(mp3ToTorrent) {
	int len = args.Length()-1; // don't count the callback
	if(len < 2) V8_STHROW(v8u::RangeErr("Not enough arguments!"));
	if(!args[len]->IsFunction()) V8_STHROW(v8u::TypeErr("A Function is needed as callback!"));
	if(!args[1]->IsObject()) V8_STHROW(v8u::TypeErr("Second argument must be an object"));

	mp3ToTorrent_req *r = new mp3ToTorrent_req();
	r->errorStatus = NO_ERROR;

	String::Utf8Value nodeOrgFilePath(args[0]->ToDetailString());
	r->orgFilePath = string(*nodeOrgFilePath);
	r->uframeDirectory = string("");
	r->torrentDirectory = string("");
	r->uframeFilePath = string("");
	r->torrentFilePath = string("");
	r->uframeHash = string("");
	r->pieceSize = 0;

	//ARRAY

	Handle<Object> object = Handle<Object>::Cast(args[1]);

	Handle<Value> objUframeDirectory = object->Get(String::New("uframeDirectory"));
	if(!objUframeDirectory->IsUndefined()) {
		String::Utf8Value nodeUframeDirectory(objUframeDirectory->ToDetailString());
		r->uframeDirectory = string(*nodeUframeDirectory);
	}

	Handle<Value> objTorrentDirectory = object->Get(String::New("torrentDirectory"));
	if(!objTorrentDirectory->IsUndefined()) {
		String::Utf8Value nodeTorrentDirectory(objTorrentDirectory->ToDetailString());
		r->torrentDirectory = string(*nodeTorrentDirectory);
	}

	Handle<Value> objPieceSize = object->Get(String::New("pieceSize"));
	if(!objTorrentDirectory->IsUndefined()) {
		Local<Integer> nodePieceSize = objPieceSize->ToInteger();
		r->pieceSize = nodePieceSize->Value();
	}

	r->cb = v8u::Persist<Function>(v8u::Cast<Function>(args[len]));
	TRANSNODE_WORK_QUEUE(mp3ToTorrent);
} TRANSNODE_WORK(mp3ToTorrent) {
	PathsManager *pathsManager = new PathsManager(r->orgFilePath);
	pathsManager->setWorkingDirectory("/tmp");
	pathsManager->setPieceSize(r->pieceSize);

	if(r->uframeDirectory.compare("") != 0)
		pathsManager->setUframeDirectory(r->uframeDirectory);

	if(r->torrentDirectory.compare("") != 0)
		pathsManager->setTorrentDirectory(r->torrentDirectory);

	FrameExtractor *frameExtractor = new FrameExtractor(pathsManager->getOrgFilePath(), pathsManager->getTemporalFile());
	int result = frameExtractor->execute();
	delete frameExtractor;

	if(result == NO_ERROR) {
		TorrentCreator *torrentCreator = new TorrentCreator(pathsManager->getUframeFilePath(),
															pathsManager->getTorrentFilePath(),
															pathsManager->getPieceSize());
		result = torrentCreator->execute();
		delete torrentCreator;
	}

	r->uframeHash = pathsManager->getFileHash();
	r->uframeFilePath = pathsManager->getUframeFilePath();
	r->torrentFilePath = pathsManager->getTorrentFilePath();

	delete pathsManager;

} TRANSNODE_WORK_AFTER(mp3ToTorrent) {
	Local<Object> responseInfo = Object::New();
	responseInfo->Set(v8u::Symbol("errorStatus"), Integer::New(r->errorStatus));
	responseInfo->Set(v8u::Symbol("orgFilePath"), String::New(r->orgFilePath.c_str()));
	responseInfo->Set(v8u::Symbol("uframeHash"), String::New(r->uframeHash.c_str()));
	responseInfo->Set(v8u::Symbol("uframeFilePath"), String::New(r->uframeFilePath.c_str()));
	responseInfo->Set(v8u::Symbol("torrentFilePath"), String::New(r->torrentFilePath.c_str()));
	responseInfo->Set(v8u::Symbol("pieceSize"), Integer::New(r->pieceSize));

	const unsigned argc = 1;
	Local<Value> argv[argc];
	argv[argc] = responseInfo;
	TRANSNODE_WORK_CALL(argc);
} TRANSNODE_END


TRANSNODE_WORK_PRE(init) {
	int errorStatus;
	
	string initConfigDir;
	//session_events_req *events;
	string initResponse;

	Persistent<Function> cb;
	Persistent<Function> event_cb;
	uv_work_t req;
};

TRANSNODE_WORK_PRE(close) {
	int errorStatus;
	
	Persistent<Function> cb;
	uv_work_t req;
};

// TODO: this should instantiate and return a TransSession obj
V8_SCB(init) {
	if(transSession != NULL) V8_STHROW(v8u::Err("TransNode already started!"));
	int len = args.Length()-1; // don't count the callback
	if(len < 2) V8_STHROW(v8u::RangeErr("Not enough arguments!"));
	if(!args[len-2]->IsFunction()) V8_STHROW(v8u::TypeErr("An event emitter function is needed as well!"));
	if(!args[len-1]->IsFunction()) V8_STHROW(v8u::TypeErr("A terminating function is needed as well!"));
	if(!args[len]->IsFunction()) V8_STHROW(v8u::TypeErr("A Function is needed as callback!"));

	init_req *r = new init_req();
	close_req *r_close = new close_req();
	//session_events_req *r_events = new session_events_req();
	
	pthread_mutex_lock(&suscribe_mutex);
	uv_async_init(uv_default_loop(), &status_change_notifier, (uv_async_cb) close);
	pthread_mutex_unlock(&suscribe_mutex);	

	r->errorStatus = NO_ERROR;
	r->initConfigDir = string("");
	if(args[0]->IsString()) {
		String::Utf8Value nodeSessionConfigDir(args[0]->ToDetailString());
		r->initConfigDir = string(*nodeSessionConfigDir);
	}

	r->cb = Persistent<Function>::New(Local<Function>::Cast(args[len]));
	r_close->cb = Persistent<Function>::New(Local<Function>::Cast(args[len-1]));
	r->event_cb = Persistent<Function>::New(Local<Function>::Cast(args[len-2]));

	TRANSNODE_WORK_QUEUE(init);
} TRANSNODE_WORK(init) {
	if(transSession != NULL) {
		r->errorStatus = SESSION_ALLREADY_CREATED;
	} else {
		transSession = new TransSession(r->initConfigDir, r->event_cb);
		r->initResponse = transSession->start();
	}
} TRANSNODE_WORK_AFTER(init) {
	Local<Object> responseInfo = Object::New();
	Local<Object> configurationInfo = Object::New();

	responseInfo->Set(v8u::Symbol("errorStatus"), Integer::New(r->errorStatus));
	if(r->errorStatus == NO_ERROR) {

		map<string,string> mapResult = tNode::Utils::simpleJsonToMap(r->initResponse);

		for(map<string, string>::iterator p = mapResult.begin(); p != mapResult.end(); p++) {
			if(!p->second.substr(0,1).compare("\"")) //Es un string
				configurationInfo->Set(v8u::Symbol(p->first.c_str()), String::New(tNode::Utils::RemoveQuotes(p->second).c_str()));
			else if(!p->second.compare("true")) //Booleano a true
				configurationInfo->Set(v8u::Symbol(p->first.c_str()), Boolean::New(true));
			else if(!p->second.compare("false")) //Booleano a false
				configurationInfo->Set(v8u::Symbol(p->first.c_str()), Boolean::New(false));
			else //Es un nÃºmero
				configurationInfo->Set(v8u::Symbol(p->first.c_str()), Integer::New(atoi(p->second.c_str())));

			responseInfo->Set(v8u::Symbol("configuration"), configurationInfo);
		}
	}

	Local<Value> argv[1];
	argv[0] = responseInfo;
	TRANSNODE_WORK_CALL(1);
} TRANSNODE_END

void close(uv_work_t *req) {
	v8::HandleScope scope;
	TRANSNODE_WORK_UNWRAP(close);

	Local<Object> responseInfo = Object::New();
	//transSession->stop();

	Local<Value> argv[1];
	argv[0] = responseInfo;
	TRANSNODE_WORK_CALL(1);
}


v8::TryCatch try_catch;

TRANSNODE_WORK_PRE(add) {
	int errorStatus;

	string nodeTorrentLocation;
	int file_offset;
	int nodeTorrentLinkType;
	
	Persistent<Function> cb;
	Handle<Object> ret;
	uv_work_t req;
};


V8_SCB(add) {
	int len = args.Length()-1; // don't count the callback
	if(len < 1) V8_STHROW(v8u::RangeErr("Not enough arguments!"));
	if(!args[len]->IsFunction()) V8_STHROW(v8u::TypeErr("A Function is needed as callback!"));

	add_req *r = new add_req();
	r->errorStatus = NO_ERROR;
	r->ret = Object::New();

	String::Utf8Value nodeTorrentLocation(args[0]->ToDetailString());
	r->nodeTorrentLocation = string(*nodeTorrentLocation);
	r->file_offset = args[1]->IsNumber() ? args[1]->ToInteger()->Value() : -1;


	r->cb = v8u::Persist<Function>(v8u::Cast<Function>(args[len]));
	TRANSNODE_WORK_QUEUE(add);
} TRANSNODE_WORK(add) {
	r->nodeTorrentLinkType = UNDEFINED_TORRENT_REFERNCE;
	//MAGNET
	if(r->nodeTorrentLocation.size()>8 && !r->nodeTorrentLocation.compare(0,8,"magnet:?")) {
		r->errorStatus = transSession->addMagnet(r->nodeTorrentLocation, r->file_offset);
		r->nodeTorrentLinkType = MAGNET_TORRENT_REFERNCE;
		
    //r->ret->Set(v8u::Symbol("magnet"), v8u::Str(r->nodeTorrentLocation.c_str()));
    ////evt_data->Set(v8u::Symbol("torrent"), v8u::Str(tor->info.hashString));
	}
	//URL
	else if(tNode::Utils::isCurlURL(r->nodeTorrentLocation.c_str())) {
		r->errorStatus = transSession->addURL(r->nodeTorrentLocation);
		r->nodeTorrentLinkType = LINK_TORRENT_REFERNCE;
	}
	//TORRENT
	else if(r->nodeTorrentLocation.size()>8 && !r->nodeTorrentLocation.compare(r->nodeTorrentLocation.size()-8,8,".torrent")) {
		r->nodeTorrentLinkType = FILE_TORRENT_REFERNCE;
		r->errorStatus = transSession->addTorrent(r->nodeTorrentLocation);
	}
	//MP3
	else if(r->nodeTorrentLocation.size()>4 && !r->nodeTorrentLocation.compare(r->nodeTorrentLocation.size()-4,4,".mp3")) {
		PathsManager *pathsManager = new PathsManager(r->nodeTorrentLocation);
		pathsManager->setWorkingDirectory("/tmp");

		FrameExtractor *frameExtractor = new FrameExtractor(pathsManager->getOrgFilePath(), pathsManager->getTemporalFile());
		int result = frameExtractor->execute();
		delete frameExtractor;

		if(result == NO_ERROR) {
			TorrentCreator *torrentCreator = new TorrentCreator(pathsManager->getUframeFilePath(),
																pathsManager->getTorrentFilePath(),
																pathsManager->getPieceSize());
			result = torrentCreator->execute();
			delete torrentCreator;
		}
		delete pathsManager;

		//LO QUE TENGA QUE HACER PARA COMPARTIR EL FICHERO

		r->nodeTorrentLinkType = MP3_TORRENT_REFERNCE;
		r->errorStatus = result;
	}
	else
	{
		r->errorStatus = UNSOPORTED_TORRENT_ADD;
	}
} TRANSNODE_WORK_AFTER(add) {
	Local<Object> responseInfo = Object::New();
	responseInfo->Set(v8u::Symbol("errorStatus"), Integer::New(r->errorStatus));
	responseInfo->Set(v8u::Symbol("linkType"), Integer::New(r->nodeTorrentLinkType));
	responseInfo->Set(v8u::Symbol("ret"), r->ret);

	const unsigned argc = 1;
	Local<Value> argv[argc];
	argv[0] = responseInfo;
	TRANSNODE_WORK_CALL(argc);
} TRANSNODE_END


TRANSNODE_WORK_PRE(list) {
	int errorStatus;
	
	TorrentsStat *torrentsStat;

	Persistent<Function> cb;
	uv_work_t req;
};

V8_SCB(list) {
	int len = args.Length()-1; // don't count the callback
	if(len < 0) V8_STHROW(v8u::RangeErr("Not enough arguments!"));
	if(!args[len]->IsFunction()) V8_STHROW(v8u::TypeErr("A Function is needed as callback!"));

	list_req *r = new list_req();
	r->errorStatus = NO_ERROR;
	r->cb = v8u::Persist<Function>(v8u::Cast<Function>(args[len]));
	TRANSNODE_WORK_QUEUE(list);
} TRANSNODE_WORK(list) {
	r->torrentsStat = transSession->listTorrents();
} TRANSNODE_WORK_AFTER(list) {
	Local<Object> responseInfo = Object::New();
	responseInfo->Set(v8u::Symbol("errorStatus"), Integer::New(r->errorStatus));

	TorrentsStat *torrentsStat = r->torrentsStat;
	Handle<Array> arrayToSend = Array::New(torrentsStat->totalTorrents);

	for(int i=0; i < torrentsStat->totalTorrents; i++) {
		Local<Object> torrentInfo = Object::New();
		torrentInfo->Set(v8u::Symbol("id"), Integer::New(torrentsStat->torrentStatList[i].id));

		if(torrentsStat->torrentStatList[i].error)
			torrentInfo->Set(v8u::Symbol("errorMark"), String::New("*"));
		else
			torrentInfo->Set(v8u::Symbol("errorMark"), String::New(" "));

		if(torrentsStat->torrentStatList[i].sizeWhenDone) {
			float done =  (torrentsStat->torrentStatList[i].sizeWhenDone - torrentsStat->torrentStatList[i].leftUntilDone) / torrentsStat->torrentStatList[i].sizeWhenDone;
			torrentInfo->Set(v8u::Symbol("done"), String::New(tNode::Utils::folatToPercent(done).c_str()));
		} else {
			torrentInfo->Set(v8u::Symbol("done"), String::New("n/a"));
		}

		torrentInfo->Set(v8u::Symbol("have"), Integer::New(torrentsStat->torrentStatList[i].sizeWhenDone - torrentsStat->torrentStatList[i].leftUntilDone));

		if(torrentsStat->torrentStatList[i].leftUntilDone || torrentsStat->torrentStatList[i].eta != -1)
			torrentInfo->Set(v8u::Symbol("eta"), String::New(tNode::Utils::intToString(torrentsStat->torrentStatList[i].eta).c_str()));
		else
			torrentInfo->Set(v8u::Symbol("eta"), String::New("Done"));

		torrentInfo->Set(v8u::Symbol("up"), Number::New(torrentsStat->torrentStatList[i].rateUpload));
		torrentInfo->Set(v8u::Symbol("down"), Number::New(torrentsStat->torrentStatList[i].rateDownload));
		torrentInfo->Set(v8u::Symbol("ratio"), Number::New(torrentsStat->torrentStatList[i].uploadRatio));
		torrentInfo->Set(v8u::Symbol("status"), String::New(transSession->getTorrentStatusString(torrentsStat->torrentStatList[i]).c_str()));
		torrentInfo->Set(v8u::Symbol("name"), String::New(torrentsStat->torrentStatList[i].name));

		//Handle<Array> files = Array::New(torrentsStat->torrentStatList[i].numFiles);
		Handle<Array> files = Array::New();
		printf("files: %d\n", torrentsStat->torrentStatList[i].numFiles);
		for(tr_file_index_t j=0; j < torrentsStat->torrentStatList[i].numFiles; j++) {
			//bytesCompleted / progress
			printf("(%d)percent: %d %f\n", j, torrentsStat->torrentStatList[i].fileStats[j].dnd, torrentsStat->torrentStatList[i].fileStats[j].progress);
			files->Set(i, Number::New(torrentsStat->torrentStatList[i].fileStats[j].progress));
		}

		torrentInfo->Set(v8u::Symbol("name"), files);
		arrayToSend->Set(i,torrentInfo);
		tr_free(torrentsStat->torrentStatList[i].fileStats);
	}

	delete torrentsStat->torrentStatList;
	delete [] torrentsStat;

	responseInfo->Set(v8u::Symbol("torrents"), arrayToSend);

	const unsigned argc = 1;
	Local<Value> argv[argc];
	argv[0] = responseInfo;
	TRANSNODE_WORK_CALL(argc);
} TRANSNODE_END


TRANSNODE_WORK_PRE(start) {
	int errorStatus;
	
	int torrentId;
	
	Persistent<Function> cb;
	uv_work_t req;
};

V8_SCB(start) {
	int len = args.Length()-1; // don't count the callback
	if(len < 1) V8_STHROW(v8u::RangeErr("Not enough arguments!"));
	if(!args[len]->IsFunction()) V8_STHROW(v8u::TypeErr("A Function is needed as callback!"));

	start_req *r = new start_req();
	r->errorStatus = NO_ERROR;
	r->torrentId = args[0]->ToInteger()->Value();
	r->cb = v8u::Persist<Function>(v8u::Cast<Function>(args[len]));
	TRANSNODE_WORK_QUEUE(start);
} TRANSNODE_WORK(start) {
	r->errorStatus = transSession->startTorrent(r->torrentId, true);
} TRANSNODE_WORK_AFTER(start) {
	Local<Object> responseInfo = Object::New();
	responseInfo->Set(v8u::Symbol("errorStatus"), Integer::New(r->errorStatus));

	const unsigned argc = 1;
	Local<Value> argv[argc];
	argv[0] = responseInfo;
	TRANSNODE_WORK_CALL(argc);
} TRANSNODE_END



TRANSNODE_WORK_PRE(stop) {
	int errorStatus;
	
	int torrentId;
	
	Persistent<Function> cb;
	uv_work_t req;
};

V8_SCB(stop) {
	int len = args.Length()-1; // don't count the callback
	if(len < 1) V8_STHROW(v8u::RangeErr("Not enough arguments!"));
	if(!args[len]->IsFunction()) V8_STHROW(v8u::TypeErr("A Function is needed as callback!"));

	stop_req *r = new stop_req();
	r->errorStatus = NO_ERROR;
	r->torrentId = args[0]->ToInteger()->Value();
	r->cb = v8u::Persist<Function>(v8u::Cast<Function>(args[len]));
	TRANSNODE_WORK_QUEUE(stop);
} TRANSNODE_WORK(stop) {
	r->errorStatus = transSession->stopTorrent(r->torrentId);
	//r->errorStatus = transSession->pauseTorrent(r->torrentId);
} TRANSNODE_WORK_AFTER(stop) {
	Local<Object> responseInfo = Object::New();
	responseInfo->Set(v8u::Symbol("errorStatus"), Integer::New(r->errorStatus));

	const unsigned argc = 1;
	Local<Value> argv[argc];
	argv[0] = responseInfo;
	TRANSNODE_WORK_CALL(argc);
} TRANSNODE_END


TRANSNODE_WORK_PRE(remove) {
	int errorStatus;
	
	int torrentId;
	bool deleteLocalData;
	
	Persistent<Function> cb;
	uv_work_t req;
};

V8_SCB(remove) {
	int len = args.Length()-1; // don't count the callback
	if(len < 2) V8_STHROW(v8u::RangeErr("Not enough arguments!"));
	if(!args[len]->IsFunction()) V8_STHROW(v8u::TypeErr("A Function is needed as callback!"));
	
	remove_req *r = new remove_req();
	r->errorStatus = NO_ERROR;
	r->torrentId = args[0]->ToInteger()->Value();
	r->deleteLocalData = args[1]->ToBoolean()->Value();
	r->cb = v8u::Persist<Function>(v8u::Cast<Function>(args[len]));
	TRANSNODE_WORK_QUEUE(remove);
} TRANSNODE_WORK(remove) {
	

	r->errorStatus = transSession->removeTorrent(r->torrentId, r->deleteLocalData);
} TRANSNODE_WORK_AFTER(remove) {
	Local<Object> responseInfo = Object::New();
	responseInfo->Set(v8u::Symbol("errorStatus"), Integer::New(r->errorStatus));

	const unsigned argc = 1;
	Local<Value> argv[argc];
	argv[0] = responseInfo;
	TRANSNODE_WORK_CALL(argc);
} TRANSNODE_END


extern "C" void init(Handle<Object> target) {
	target->Set(v8u::Symbol("mp3ToTorrent"), FunctionTemplate::New(mp3ToTorrent)->GetFunction());
	target->Set(v8u::Symbol("init"), FunctionTemplate::New(init)->GetFunction());
	target->Set(v8u::Symbol("add"), FunctionTemplate::New(add)->GetFunction());
	target->Set(v8u::Symbol("list"), FunctionTemplate::New(list)->GetFunction());
	target->Set(v8u::Symbol("start"), FunctionTemplate::New(start)->GetFunction());
	target->Set(v8u::Symbol("stop"), FunctionTemplate::New(stop)->GetFunction());
	target->Set(v8u::Symbol("remove"), FunctionTemplate::New(remove)->GetFunction());
}

NODE_MODULE(TransNode, init)



